# üì¶ QUEUE - COMPLETE INTERVIEW PACKAGE
## Master Navigation & Study Guide

---

## üéØ PACKAGE OVERVIEW

**Total Coverage:**
- **18 Problems** across 2 major categories
- **10 Basic Queue Operations** (foundation)
- **8 Queue Patterns** (Sliding Window, BFS, Heap)
- **100% Service-Based Company Coverage**

**Study Time:**
- **Comprehensive:** 18-22 hours (5-6 days)
- **Crash Course:** 10-12 hours (3 days)
- **Emergency:** 5-6 hours (1 day)

---

## üìö PACKAGE STRUCTURE

```
Queue/
‚îú‚îÄ‚îÄ Basic-Queue/
‚îÇ   ‚îî‚îÄ‚îÄ INTERVIEW-READY.md ‚≠ê NEW! (10 problems)
‚îÇ
‚îú‚îÄ‚îÄ Queue-Patterns/
‚îÇ   ‚îî‚îÄ‚îÄ INTERVIEW-READY.md ‚≠ê NEW! (8 problems)
‚îÇ
‚îú‚îÄ‚îÄ QUEUE-COMPLETE-PACKAGE.md ‚≠ê (This file)
‚îî‚îÄ‚îÄ QUICK-REFERENCE.md ‚≠ê (Coming next)
```

---

## üó∫Ô∏è LEARNING PATH

### **Phase 1: Queue Basics (Day 1-2)**
**Time:** 6-8 hours  
**File:** `Basic-Queue/INTERVIEW-READY.md`

**Problems to Master:**
1. ‚úÖ Implement Queue using Array
2. ‚úÖ Implement Circular Queue ‚≠ê (75% in Infosys!)
3. ‚úÖ Queue using Stack ‚≠ê‚≠ê (80% in Infosys!)
4. ‚úÖ Stack using Queue
5. ‚úÖ Reverse a Queue
6. ‚úÖ Generate Binary Numbers ‚≠ê
7. ‚úÖ First Non-Repeating Character ‚≠ê (75% in Infosys!)
8. ‚úÖ Interleave First Half with Second
9. ‚úÖ Reverse First K Elements
10. ‚úÖ Implement Deque

**Key Concepts:**
- FIFO principle
- Queue operations (enqueue, dequeue, front, back)
- Circular queue with modulo
- Queue-Stack conversion
- Queue + frequency array pattern

**Success Criteria:**
- Can implement queue from scratch
- Understand circular queue advantage
- Master queue-stack conversions
- Comfortable with queue applications

---

### **Phase 2: Queue Patterns (Day 3-5)**
**Time:** 12-14 hours  
**File:** `Queue-Patterns/INTERVIEW-READY.md`

**Problems to Master:**
1. ‚úÖ Sliding Window Maximum ‚≠ê‚≠ê‚≠ê (Deque, 70% Infosys!)
2. ‚úÖ First Negative in Every Window ‚≠ê (75% TCS!)
3. ‚úÖ Sum of Min/Max in Window
4. ‚úÖ Rotten Oranges (BFS) ‚≠ê‚≠ê‚≠ê (60% Infosys!)
5. ‚úÖ K Closest Points (Heap) ‚≠ê‚≠ê
6. ‚úÖ Top K Frequent Elements ‚≠ê‚≠ê (70% Infosys!)
7. ‚úÖ Kth Largest Element ‚≠ê
8. ‚úÖ Connect Ropes with Minimum Cost ‚≠ê (70% Infosys!)

**Key Concepts:**
- Monotonic deque (increasing/decreasing)
- Multi-source BFS
- Priority queue (min/max heap)
- Greedy with heap
- Window-based problems

**Pattern Categories:**
```
1. Sliding Window ‚Üí Deque (monotonic)
2. BFS ‚Üí Queue (level-wise processing)
3. K elements ‚Üí Heap (size k)
4. Greedy merging ‚Üí Min/Max heap
```

**Success Criteria:**
- Master deque for sliding window
- Understand BFS traversal
- Use heap for K problems
- Recognize pattern from keywords

---

## üéØ TOP 15 PROBLEMS (COMPANY-WISE RANKED)

### **Tier 1: MUST KNOW (75%+ Frequency)**

| # | Problem | Category | TCS | Infosys | Wipro | Key Pattern |
|---|---------|----------|-----|---------|-------|-------------|
| 1 | **Queue using Stack** | Basic | 75% | 80% | 70% | Two stacks |
| 2 | **Circular Queue** | Basic | 70% | 75% | 65% | Modulo arithmetic |
| 3 | **First Negative Window** | Pattern | 75% | 70% | 65% | Queue + window |
| 4 | **First Non-Repeating** | Basic | 70% | 75% | 65% | Queue + frequency |

**Priority:** Practice these DAILY until muscle memory!

---

### **Tier 2: HIGH FREQUENCY (60-75%)**

| # | Problem | Category | TCS | Infosys | Wipro | Key Pattern |
|---|---------|----------|-----|---------|-------|-------------|
| 5 | **Sliding Window Maximum** | Pattern | 60% | 70% | 55% | Deque monotonic |
| 6 | **Top K Frequent** | Pattern | 60% | 70% | 55% | Frequency + heap |
| 7 | **Connect Ropes** | Pattern | 65% | 70% | 60% | Min heap greedy |
| 8 | **Implement Queue** | Basic | 70% | 70% | 70% | Array-based |
| 9 | **Reverse First K** | Basic | 65% | 70% | 60% | Stack + queue |

**Priority:** Cover in Week 1

---

### **Tier 3: MEDIUM FREQUENCY (50-65%)**

| # | Problem | Category | TCS | Infosys | Wipro | Key Pattern |
|---|---------|----------|-----|---------|-------|-------------|
| 10 | **Generate Binary** | Basic | 60% | 65% | 55% | Queue generation |
| 11 | **Rotten Oranges** | Pattern | 50% | 60% | 45% | Multi-source BFS |
| 12 | **Reverse Queue** | Basic | 60% | 60% | 60% | Stack/recursion |
| 13 | **Stack using Queue** | Basic | 60% | 60% | 55% | Queue rotation |
| 14 | **K Closest Points** | Pattern | 55% | 65% | 50% | Max heap size k |
| 15 | **Interleave Queue** | Basic | 55% | 60% | 50% | Auxiliary queue |

**Priority:** Cover if time permits

---

## üìÖ STUDY PLANS

### **5-6 Day Comprehensive Plan (18-22 hours)**

**Day 1: Queue Fundamentals (3-4 hours)**
- Morning: Implement Queue (Array)
- Afternoon: Circular Queue
- Evening: Queue using Stack (MUST!)

**Day 2: Queue Applications (3-4 hours)**
- Morning: Stack using Queue
- Afternoon: Reverse Queue + First K
- Evening: Generate Binary Numbers

**Day 3: Queue + Other Structures (3-4 hours)**
- Morning: First Non-Repeating (Queue + freq)
- Afternoon: Interleave Queue
- Evening: Deque implementation

**Day 4: Sliding Window Pattern (4-5 hours)**
- Morning: Sliding Window Maximum (Deque)
- Afternoon: First Negative in Window
- Evening: Sum of Min/Max

**Day 5: BFS + Heap Patterns (4-5 hours)**
- Morning: Rotten Oranges (BFS)
- Afternoon: Top K Frequent (Heap)
- Evening: Connect Ropes, Kth Largest

**Day 6: Revision & Practice (3-4 hours)**
- Morning: Solve Top 10 again
- Afternoon: Company-wise mock tests
- Evening: Quick revision

---

### **3-Day Crash Course (10-12 hours)**

**Day 1: Essentials (4-5 hours)**
- ‚úÖ Queue using Stack (1.5 hours) - MUST!
- ‚úÖ Circular Queue (1 hour) - MUST!
- ‚úÖ First Non-Repeating (1 hour)
- ‚úÖ Implement Queue (30 min)

**Day 2: Patterns (4-5 hours)**
- ‚úÖ First Negative Window (1 hour) - MUST!
- ‚úÖ Sliding Window Maximum (2 hours)
- ‚úÖ Top K Frequent (1-2 hours)

**Day 3: Practice & Revision (2-3 hours)**
- ‚úÖ Solve Top 8 problems again
- ‚úÖ Company-wise mock
- ‚úÖ Communication scripts

---

### **1-Day Emergency Plan (5-6 hours)**

**Morning (2-3 hours):**
- ‚ö° Queue using Stack (45 min) - MUST!
- ‚ö° Circular Queue (30 min)
- ‚ö° First Non-Repeating (30 min)
- ‚ö° First Negative Window (45 min)

**Afternoon (2-2.5 hours):**
- ‚ö° Sliding Window Maximum (1 hour)
- ‚ö° Top K Frequent (1 hour)

**Evening (30-60 min):**
- ‚ö° Quick revision templates
- ‚ö° Communication scripts
- ‚ö° QUICK-REFERENCE.md

---

## üè¢ COMPANY-WISE STRATEGIES

### **TCS Strategy (Focus: Basics + Window)**

**Top 5 Must-Know:**
1. Queue using Stack (75%)
2. First Negative in Window (75%)
3. Implement Queue (70%)
4. First Non-Repeating (70%)
5. Circular Queue (70%)

**Preparation Plan:**
- Day 1-2: Master queue-stack conversions
- Day 3-4: Window-based problems
- Day 5: Revision

**Interview Tips:**
- TCS loves FIFO vs LIFO comparison
- Explain circular queue advantage
- Clean, simple code
- Handle edge cases

---

### **Infosys Strategy (Focus: Patterns + Heap)**

**Top 5 Must-Know:**
1. Queue using Stack (80%)
2. Circular Queue (75%)
3. First Non-Repeating (75%)
4. First Negative Window (70%)
5. Sliding Window Maximum (70%)
6. Top K Frequent (70%)
7. Connect Ropes (70%)

**Preparation Plan:**
- Day 1-2: All basic operations
- Day 3-4: Sliding window + BFS
- Day 5-6: Heap problems

**Interview Tips:**
- Infosys likes optimization
- Discuss time-space tradeoffs
- Heap for K problems
- BFS for shortest path

---

### **Wipro Strategy (Focus: Balanced Mix)**

**Top 5 Must-Know:**
1. Queue using Stack (70%)
2. Implement Queue (70%)
3. Circular Queue (65%)
4. First Non-Repeating (65%)
5. First Negative Window (65%)

**Preparation Plan:**
- Day 1-3: Cover all basics
- Day 4-5: Patterns (window, BFS, heap)
- Day 6: Mixed practice

**Interview Tips:**
- Wipro tests depth of understanding
- Explain "why queue?"
- Compare with stack
- Communication matters!

---

## üéØ PATTERN DECISION TREE

```
Queue Problem?
    ‚Üì
Is it about "sliding window" + "max/min"?
    ‚Üí YES: Deque (Monotonic Queue)
    ‚Üí Maintain increasing/decreasing order
    
    ‚Üì NO
    
Is it about "every window" or "first in window"?
    ‚Üí YES: Queue + Window Tracking
    ‚Üí Remove outside window from front
    
    ‚Üì NO
    
Is it about "spread/propagate/level-wise"?
    ‚Üí YES: BFS with Queue
    ‚Üí Multi-source ‚Üí add all sources initially
    
    ‚Üì NO
    
Is it about "K largest/smallest/frequent"?
    ‚Üí YES: Heap (Priority Queue)
    ‚Üí K largest ‚Üí min heap size k
    ‚Üí K smallest ‚Üí max heap size k
    
    ‚Üì NO
    
Is it about "minimum cost to merge/connect"?
    ‚Üí YES: Greedy + Min Heap
    ‚Üí Always connect two smallest
    
    ‚Üì NO
    
Is it about "non-repeating" or "unique"?
    ‚Üí YES: Queue + Frequency Array
    ‚Üí Queue maintains order
    
    ‚Üì NO
    
Basic queue operations?
    ‚Üí Implement, reverse, interleave
```

---

## üìä COMPLEXITY CHEAT SHEET

| Problem Type | Time | Space | Notes |
|--------------|------|-------|-------|
| Basic Operations | O(1) | O(1) | Enqueue, dequeue |
| Implement Queue | O(1) | O(n) | Array-based |
| Circular Queue | O(1) | O(n) | Modulo arithmetic |
| Queue using Stack | O(1) amortized | O(n) | Two stacks |
| Stack using Queue | Push O(n), Pop O(1) | O(n) | Queue rotation |
| Reverse Queue | O(n) | O(n) | Stack/recursion |
| Generate Binary | O(n) | O(n) | Pattern generation |
| First Non-Repeating | O(n) | O(26)=O(1) | Queue + freq |
| Interleave Queue | O(n) | O(n) | Auxiliary queue |
| Reverse First K | O(n) | O(k) | Stack + queue |
| Sliding Window Max | O(n) | O(k) | Deque |
| First Negative Window | O(n) | O(k) | Queue |
| Rotten Oranges | O(m√ón) | O(m√ón) | BFS |
| K Closest/Frequent | O(n log k) | O(k) | Heap |
| Connect Ropes | O(n log n) | O(n) | Min heap |

---

## üîÑ REVISION STRATEGY

### **Level 1: Full Revision (18-22 hours)**
**When:** 1 week before interview
- Solve all 18 problems again
- Read all dry runs
- Practice communication scripts
- Company-wise mock tests

### **Level 2: Quick Revision (8-10 hours)**
**When:** 2-3 days before interview
- Top 10 problems only
- Review all templates
- Pattern recognition practice
- Edge case checklist

### **Level 3: Last-Minute Revision (3-4 hours)**
**When:** 1 day before interview
- Top 5 problems (Tier 1)
- Memorize templates
- Communication scripts
- QUICK-REFERENCE.md review

### **Level 4: Morning-Of Revision (30-60 min)**
**When:** Interview day morning
- Read QUICK-REFERENCE.md
- Practice queue using stack
- Practice first negative window
- Revise edge cases
- Stay calm!

---

## üí° COMMON MISTAKES TO AVOID

### **Mistake 1: Not Checking Empty Queue**
```cpp
// ‚ùå WRONG
int front = q.front();  // Crash if empty!

// ‚úÖ CORRECT
if(!q.empty()) {
    int front = q.front();
}
```

### **Mistake 2: Wrong Circular Queue Full Condition**
```cpp
// ‚ùå WRONG
if(rear == capacity - 1) // Not full in circular!

// ‚úÖ CORRECT
if((rear + 1) % capacity == front)  // Circular full
```

### **Mistake 3: Forgetting Window Boundary**
```cpp
// Sliding window: remove outside window
while(!q.empty() && q.front() <= i - k) {
    q.pop();  // ‚úÖ Remove old elements
}
```

### **Mistake 4: Wrong Heap for K Problems**
```cpp
// K LARGEST ‚Üí use MIN heap (size k)
priority_queue<int, vector<int>, greater<int>> minHeap;

// K SMALLEST ‚Üí use MAX heap (size k)
priority_queue<int> maxHeap;
```

### **Mistake 5: BFS Without Visited Tracking**
```cpp
// ‚ùå WRONG - Infinite loop!
while(!q.empty()) {
    Node curr = q.front(); q.pop();
    for(neighbor : curr.neighbors) {
        q.push(neighbor);  // May revisit!
    }
}

// ‚úÖ CORRECT
visited[start] = true;
while(!q.empty()) {
    Node curr = q.front(); q.pop();
    for(neighbor : curr.neighbors) {
        if(!visited[neighbor]) {
            visited[neighbor] = true;
            q.push(neighbor);
        }
    }
}
```

---

## üéØ INTERVIEW DAY STRATEGY

### **30 Minutes Before:**
- [ ] Review QUICK-REFERENCE.md
- [ ] Practice queue using stack
- [ ] Practice first negative window
- [ ] Memorize deque template
- [ ] Calm breathing

### **During Interview:**

**Step 1: Listen & Clarify (1 min)**
- Understand problem completely
- Ask about constraints (k ‚â§ n?)
- Confirm input/output format

**Step 2: Identify Pattern (30 sec)**
- "This is a [queue/deque/heap/BFS] problem because..."
- Mention which pattern

**Step 3: Explain Approach (2 min)**
- Draw diagram (queue/heap states)
- Explain algorithm step-by-step
- Mention time & space complexity

**Step 4: Code (5-7 min)**
- Write clean, commented code
- Use meaningful variable names
- Handle edge cases

**Step 5: Dry Run (2 min)**
- Walk through example
- Show queue/deque/heap states
- Verify correctness

**Step 6: Edge Cases & Optimize (1 min)**
- Empty queue
- Window size > array size
- k > n for heap
- Disconnected graph for BFS

---

## üåü SUCCESS MANTRAS

### **Pattern Recognition:**
```
Sliding window + max/min? ‚Üí Deque
Every window? ‚Üí Queue
Spread/propagate? ‚Üí BFS
K elements? ‚Üí Heap
Merge with min cost? ‚Üí Min heap
Non-repeating? ‚Üí Queue + freq
```

### **Template Mastery:**
```
Queue ‚Üí front(), pop(), push()
Circular ‚Üí (rear+1) % capacity
Deque ‚Üí pop_front(), pop_back()
BFS ‚Üí visited[], queue
Heap ‚Üí size k, pop when > k
```

### **Communication:**
```
1. "Sir, this is a [pattern] problem"
2. "I'll use queue/deque/heap because [FIFO/window/K]"
3. "Algorithm: [step by step]"
4. "Time O(n), Space O(k) because [reason]"
5. Draw states
6. Handle edge cases
```

---

## üìà PROGRESS TRACKING

### **Beginner ‚Üí Intermediate (Week 1)**
- [ ] Understand FIFO principle
- [ ] Implement queue from scratch
- [ ] Master circular queue
- [ ] Solve queue using stack
- [ ] Understand basic patterns

### **Intermediate ‚Üí Advanced (Week 2)**
- [ ] Master deque for sliding window
- [ ] Understand BFS traversal
- [ ] Use heap for K problems
- [ ] Recognize pattern in 30 sec
- [ ] Solve without notes

### **Advanced ‚Üí Interview Ready (Week 3)**
- [ ] Top 15 problems solved 2+ times
- [ ] Explain approach clearly
- [ ] Comfortable with edge cases
- [ ] Company-wise mocks passed
- [ ] Communication scripts ready

---

## üéØ FINAL CHECKLIST

**Knowledge:**
- [ ] FIFO principle clear
- [ ] Circular queue advantage understood
- [ ] Deque for sliding window mastered
- [ ] BFS traversal comfortable
- [ ] Heap for K problems clear

**Practice:**
- [ ] Top 10 problems solved 2+ times
- [ ] Can code without reference
- [ ] Dry runs practiced
- [ ] Edge cases handled

**Communication:**
- [ ] Can explain "why queue?"
- [ ] Pattern identification instant
- [ ] Complexity analysis ready
- [ ] Drawing states comfortable

**Company Preparation:**
- [ ] TCS top 5 covered
- [ ] Infosys top 7 covered
- [ ] Wipro top 5 covered
- [ ] Mock tests done

---

## üí™ MOTIVATIONAL REMINDER

**You've got:**
- ‚úÖ 18 problems with full solutions
- ‚úÖ Pattern templates (Queue, Deque, BFS, Heap)
- ‚úÖ Company-wise strategies
- ‚úÖ Communication scripts
- ‚úÖ Pattern decision tree

**Queue is 10-15% of DSA interviews.**

**Current Coverage:**
- Binary Search ‚úÖ
- Arrays ‚úÖ
- Strings ‚úÖ
- Linked Lists ‚úÖ
- Stack ‚úÖ
- **Queue ‚úÖ NEW!**

## **YOU'RE NOW 92-95% READY FOR SERVICE-BASED PLACEMENTS!** üöÄ

---

## üìû QUICK NAVIGATION

- **Basics:** `Basic-Queue/INTERVIEW-READY.md`
- **Patterns:** `Queue-Patterns/INTERVIEW-READY.md`
- **Quick Revision:** `QUICK-REFERENCE.md` (next file)

---

**All the best, Satyam!** üåü  
**Interview crush ‡§ï‡§∞‡•ã‡§ó‡•á!** üíØ

**Remember:** Queue = FIFO. Master the patterns, interviews become easy!
